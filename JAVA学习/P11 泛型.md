# P11 泛型

# 1.什么是泛型？

**泛型：**是JDK5引入的特性，在编译阶段进行数据类型检查。

**泛型的格式：**<数据类型>

**注意：**泛型只能支持引用数据类型

```
LinkedList<String> lists = new LinkedList<>();
lists.add("aaa");
lists.add("bbb");
lists.add("ccc");
```

**好处**

- 统一数据类型
- 把运行期间的问题提前到了编译时期，避免强制转换可能出现的异常，因为在编译阶段就能确定下来类型。

# 2.没有泛型前，如何存储数据？

如果没有给集合指定类型，默认所有的类型都是Object类型的，可以向集合添加任意类型的数据，但是无法使用数据类型的特有行为，例如String类的length这些。

```
ArrayList arrayList = new ArrayList();
arrayList.add(0);
arrayList.add("string");
arrayList.add(1.0f);
System.out.println(arrayList);  //[0, string, 1.0]
```

 

# 3.泛型的细节

泛型中不能写基本的数据类型

如果不写泛型，类型默认是Object



# 4.泛型的使用

## 4.1 泛型类

当一个类，某个变量的数据类型不确定时候，就可以定义带有泛型的类（在类名后面定义 ）。

此处的E可以理解为变量，但是不是用于记录数据的，而是用来记录数据的类型，可以写成T、E、K、V等



![image-20240413180506977](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240413180506977.png)

自己定义的泛型类MyArrayList.java

**单个泛型**

```
package Test;

import java.util.Arrays;

//E表示我们不确定类型
public class MyArrayList<E> {
    private Object[] obj = new Object[10];
    private int size;

     public boolean add(E e) {
        obj[size] = e;
        size++;
        return true;
    }

    public E get(int index) {
        return (E)obj[index];
    }

    public String toString() {
        return Arrays.toString(obj);
    }
}

```

使用多个泛型时

```
package Generics;

public class MulGenerics<E,V> {
    E name;
    V age;

    public MulGenerics() {
    }

    public MulGenerics(E name, V age) {
        this.name = name;
        this.age = age;
    }

    /**
     * 获取
     * @return name
     */
    public E getName() {
        return name;
    }

    /**
     * 设置
     * @param name
     */
    public void setName(E name) {
        this.name = name;
    }

    /**
     * 获取
     * @return age
     */
    public V getAge() {
        return age;
    }

    /**
     * 设置
     * @param age
     */
    public void setAge(V age) {
        this.age = age;
    }

    public String toString() {
        return "MulGenerics{name = " + name + ", age = " + age + "}";
    }
}


```

测试

```
package Test;

import java.util.Scanner;

public class test {

    public static void main(String[] args) {
        MyArrayList<String> arrayList = new MyArrayList<>();
        arrayList.add("aaa");
        arrayList.add("bbb");
        System.out.println(arrayList);  //[aaa, bbb, null, null, null, null, null, null, null, null]  我们设置默认开辟是个空间
        
        MulGenerics<String,Integer> mulGenerics = new MulGenerics<>("jack",15); //MulGenerics{name = jack, age = 15}
        System.out.println(mulGenerics);

    }

}

```







## 4.2 泛型方法

方法中的形参不确定的时候。

注意：public和static都是修饰符，因此泛型<E>只能最后的修饰符后面，例如下面的只能写到static后面而不是public后面。

![image-20240413182147708](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240413182147708.png)

```java
package Test;

import java.util.ArrayList;
import java.util.Scanner;

public class test {

    public static void main(String[] args) {
       ArrayList<Integer> list1 = new ArrayList<>();
       addAll(list1,1,2);
       System.out.println(list1);//[1, 2]

       ArrayList<String> list2 = new ArrayList<>();
       addAll2(list2,"aaa","bbb","ccc");
       System.out.println(list2);//[aaa, bbb, ccc]

    }

    public static<E> void addAll(ArrayList<E> list,E e1,E e2) {
        list.add(e1);
        list.add(e2);
    }

    //E...e表示可变参数，可以传一个可以传多个，底层是一个数组
    static<E> void addAll2(ArrayList<E> list,E ...e) {
        for (E ele:e) {
            list.add(ele);
        }
    }

}
static<E> void printList2(List<E> list) {
    for (E l : list) {
    	System.out.print(l + " ");
    }
    System.out.println();
}
    
public static<E> void printList2(List<E> list) {
    for (E l : list) {
    	System.out.print(l + " ");
    }
    System.out.println();
}
```





## 4.3 泛型接口

例如：List.java

```
public interface List<E> extends Collection<E> {
}
```

![image-20240413205352879](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240413205352879.png)

### 4.3.1 方式一：实现类给出具体的类型

这种通常是确定了数据类型，例如下面我们自己创建的List实现了List的接口，默认是<E>,但是我们现在已经确定要操作的数据类型是String，因此直接写String就可以。

**例子1：**

MyArrayListTest.java

```
package Generics;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

public class MyArrayListTest implements List<String> {
    @Override
    public int size() {
        return 0;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public boolean contains(Object o) {
        return false;
    }

    @Override
    public Iterator<String> iterator() {
        return null;
    }

    @Override
    public Object[] toArray() {
        return new Object[0];
    }

    @Override
    public <T> T[] toArray(T[] ts) {
        return null;
    }

    @Override
    public boolean add(String s) {
        return false;
    }

    @Override
    public boolean remove(Object o) {
        return false;
    }

    @Override
    public boolean containsAll(Collection<?> collection) {
        return false;
    }

    @Override
    public boolean addAll(Collection<? extends String> collection) {
        return false;
    }

    @Override
    public boolean addAll(int i, Collection<? extends String> collection) {
        return false;
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
        return false;
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
        return false;
    }

    @Override
    public void clear() {

    }

    @Override
    public String get(int i) {
        return null;
    }

	//这里的传值是String
    @Override
    public String set(int i, String s) {
        return null;
    }

	//这里的传值是String
    @Override
    public void add(int i, String s) {

    }

    @Override
    public String remove(int i) {
        return null;
    }

    @Override
    public int indexOf(Object o) {
        return 0;
    }

    @Override
    public int lastIndexOf(Object o) {
        return 0;
    }

    @Override
    public ListIterator<String> listIterator() {
        return null;
    }

    @Override
    public ListIterator<String> listIterator(int i) {
        return null;
    }

    @Override
    public List<String> subList(int i, int i1) {
        return null;
    }
}

```

例子2：这里我们要进行的是比较操作，比较的对象是Student已经确定下来了，而不是在创建时候再确定，因此可以直接写Student。

```
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;

public class setTest {
    public static void main(String[] args){
        Student stu1 = new Student("xiaozhou",13);
        Student stu2 = new Student("xiaopeng",14);
        Student stu3 = new Student("xiaoyu",15);
        Student stu4 = new Student("xiaozhou",13);
        Student stu5 = new Student("xiaosun",17);

        //[Student{name='xiaozhou', age=13}, Student{name='xiaopeng', age=14},
        //Student{name='xiaoyu', age=15}, Student{name='xiaosun', age=17}]
        TreeSet<Student> studentTreeSet = new TreeSet<>();
        studentTreeSet.add(stu3);
        studentTreeSet.add(stu4);
        studentTreeSet.add(stu5);
        studentTreeSet.add(stu1);
        studentTreeSet.add(stu2);

        System.out.println(studentTreeSet);
    }
}

class Student implements Comparable<Student>{
    private String name;
    private int age;

    Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student student) {
        return this.age - student.age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}



```



### 4.3.2 方式2：实现类继续延续泛型，创建对象时再确定

```
package Generics;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

public class MyArrayListTest2<E> implements List<E> {
    @Override
    public int size() {
        return 0;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public boolean contains(Object o) {
        return false;
    }

    @Override
    public Iterator<E> iterator() {
        return null;
    }

    @Override
    public Object[] toArray() {
        return new Object[0];
    }

    @Override
    public <T> T[] toArray(T[] ts) {
        return null;
    }

	//这里的传值是泛型E
    @Override
    public boolean add(E e) {
        return false;
    }

    @Override
    public boolean remove(Object o) {
        return false;
    }

    @Override
    public boolean containsAll(Collection<?> collection) {
        return false;
    }

    @Override
    public boolean addAll(Collection<? extends E> collection) {
        return false;
    }

    @Override
    public boolean addAll(int i, Collection<? extends E> collection) {
        return false;
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
        return false;
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
        return false;
    }

    @Override
    public void clear() {

    }

    @Override
    public E get(int i) {
        return null;
    }

	//这里的传值是泛型E
    @Override
    public E set(int i, E e) {
        return null;
    }

	//这里的传值是泛型E
    @Override
    public void add(int i, E e) {

    }

    @Override
    public E remove(int i) {
        return null;
    }

    @Override
    public int indexOf(Object o) {
        return 0;
    }

    @Override
    public int lastIndexOf(Object o) {
        return 0;
    }

    @Override
    public ListIterator<E> listIterator() {
        return null;
    }

    @Override
    public ListIterator<E> listIterator(int i) {
        return null;
    }

    @Override
    public List<E> subList(int i, int i1) {
        return null;
    }
}

```



### 4.3.3 调试

```
package Generics;

public class Test {
    public static void main(String[] args) {
        /*
        * 实现类直接给出类型，这里就是List中的泛型类型直接就是String
        * public class MyArrayListTest implements List<String>{
        * add方法也会被限定到String，这里添加Integer就会报错
        * }
        * */
        MyArrayListTest list = new MyArrayListTest();
        list.add("aaa");    //正确，因为实现类直接给出类型，这里就是List中的泛型类型直接就是String
//        list.add(111);    //错误，因为限定的类型是String，无法添加其他引用类型

        /*
        * 实现类继续延续泛型，创建实现类的对象时再确定类型
        * public class MyArrayListTest2<E> implements List<E> {
        * 可以看到add方法中传入参数是E，泛型
        * }
        * */
        MyArrayListTest2<String> list2 = new MyArrayListTest2<>();
        list2.add("aaa");
    }
}

```



# 5.泛型的继承和通配符  

## 5.1 通配符几种形式

？也表示不确定的类型，<E>等同于<?>

? extends E:表示可以传递E以及E的子类

? super E:表示可以传递E以及E的父类



## 5.2 应用场景

我们在定义类，方法，接口时，如果是不确定的类型，可以定义泛型类，泛型方法，泛型接口；

如果类型不确定，但是能知道大概以后只能传递哪一个继承体系的，就可以使用通配符



通配符关键点是在于可以限定传递的数据类型的范围







## 5.3 测试

1.泛型不具有继承性，但是数据具有继承性

2.通配符

```
package Generics;

import java.util.ArrayList;

public class Test2 {

    public static void main(String[] args) {
        ArrayList<Person> list1 = new ArrayList<>();
        ArrayList<Male> list2 = new ArrayList<>();
        ArrayList<Boy> list3 = new ArrayList<>();
        ArrayList<Food> list4 = new ArrayList<>();

        method1(list1);
        method1(list2);
        method1(list3);
//        method1(list4);   //不能调用

        method2(list1);
        method2(list2);
//        method2(list3);

        method3(list1);
//        method3(list2); //不能调用，泛型不具有继承性

        list1.add(new Male());  //数据具有继承性，可以直接使用


    }

    //只有Person以及继承于Person的子类才能传入
    public static void method1(ArrayList<? extends Person> list) {
    }

    //只有Male以及Male的父类才满足条件
    public static void method2(ArrayList<? super Male> list) {
    }

    //只有Person的ArrayList才能传递，Male和Boy不能传递
    public static void method3(ArrayList<Person> list) {
    }
}

class Person{

}

class Male extends Person{

}

class Boy extends Male{

}

class Food {

}







```


# P12 多线程

# 1.进程、线程和程序

程序是数组和代码，是静态的。

进程是程序的基本执行实体。

线程是操作系统中能够运行调度的最小单位。包含在进程当中，依赖于进程存在，是进程的实际运作单位，一个进程可以有多个线程。





# 2.什么是多线程？为什么会有多线程？多线程的应用场景？

有了多线程，可以让程序同时做多件事情。

多线程的存在是因为可以提高效率。





多线程的应用场景：

只要想让多个事情同时运行，就需要用到多线程。

例如：

游戏中加载大量的资源文件同时，播放背景音乐，显示画面等等

聊天软件发消息时候可以收消息，可以打开其他功能



# 3.多线程中的并发和并行？

计算机通常是多核多线程的，例如双核四线程，四核八线程，八核十六线程等等。

并发：同一时刻，有多个指令在单个CPU上交替执行。

例如：打游戏的同时，喝水，接电话等等，交替执行。

并行：在同一时刻，在多个CPU上同时执行。







# 4.多线程实现方式？

三种方式：继承Thread，实现Runnable接口以及实现Callable接口并使用FutureTask

## 4.1 继承Thread类

步骤：

1）自己定义一个类MyThread继承Thread类

2）重写run方法

3）创建MyThread对象

4）调用MyThread.start



MyThread.java

```
package ThreadDemo;

public class MyThread extends Thread{

    public MyThread() {
    }

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() +"执行继承Thread的run方法");
        }
    }
}

```



测试

```java
    public static void testExtendsThread() {
        System.out.println("------------------");
        System.out.println("创建MyThread线程，并调用start启动该线程");
        MyThread myThread1 = new MyThread();
        myThread1.setName("线程1:");
        myThread1.start();
        MyThread myThread2 = new MyThread("线程2:");
        myThread2.start();
//        new MyThread().start();
    }
```



## 4.2 实现Runnable接口

步骤：

1）自己定义一个类MyRunnable实现Runnable接口

2）重写run方法

3）创建MyRunnable对象myRunnable

4）创建Thread对象，并将myRunnable作为参数传入

5）调用MyThread.start（注意这里不是直接调用myRunnable.run)

MyRunnable.java

```
package ThreadDemo;

public class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("执行实现Runnable的run方法");
        }
    }
}

```

测试

```
    public static void testImplementsRunnable() {
        System.out.println("------------------");
        System.out.println("创建myRunnable对象，创建Thread线程并传入Runnable对象，并调用start启动该线程");
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
```



## 4.3 实现Callable接口并使用FutureTask接口

步骤：

1）自己定义一个类MyCallable实现Callable接口

2）重写call方法（是有返回值的，start执行之后可以通过FutureTask的get方法获取)

3）创建MyCallable对象myCallable（MyCallable表示多线程要执行的任务）

4）创建FutureTask对象futureTask，并将myCallable作为参数传入（FutureTask作用是管理多线程运行的结果）

5）创建Thread对象myThread，并将futureTask作为参数传入

6）调用myThread.start

MyCallable.java

```
package ThreadDemo;

import java.util.concurrent.Callable;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int num = 0;
        for (int i = 0; i < 100; i++) {
            num += i;
        }
        return num;
    }
}

```

测试

```
    public static void testImplementsCallable() {
        System.out.println("------------------");
        System.out.println("创建Callable对象，传入到FutureTask中，再将FutureTask传入到新建的线程中，并调用start启动该线程");
        MyCallable myCallable = new MyCallable();
        //FutureTask<V> implements RunnableFuture<V> ，RunnableFuture<V> extends Runnable, Future<V>
        FutureTask<Integer> futureTask = new FutureTask<>(myCallable);
        Thread thread = new Thread(futureTask);
        thread.start();

        try {
            Integer sum = futureTask.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
```



## 4.4 测试



```
package ThreadDemo;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class ThreadTest {
    public static void main(String[] args) {
    	//注意这里会交替输出三个线程的输出结果，因为是多线程，具有随机性
        testExtendsThread();
        testImplementsRunnable();
        testImplementsCallable();

    }

    public static void testExtendsThread() {
        System.out.println("------------------");
        System.out.println("创建MyThread线程，并调用start启动该线程");
        MyThread myThread1 = new MyThread();
        myThread1.setName("线程1:");
        myThread1.start();
        MyThread myThread2 = new MyThread("线程2:");
        myThread2.start();
//        new MyThread().start();
    }

    public static void testImplementsRunnable() {
        System.out.println("------------------");
        System.out.println("创建myRunnable对象，创建Thread线程并传入Runnable对象，并调用start启动该线程");
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }

    public static void testImplementsCallable() {
        System.out.println("------------------");
        System.out.println("创建Callable对象，传入到FutureTask中，再将FutureTask传入到新建的线程中，并调用start启动该线程");
        MyCallable myCallable = new MyCallable();
        //FutureTask<V> implements RunnableFuture<V> ，RunnableFuture<V> extends Runnable, Future<V>
        FutureTask<Integer> futureTask = new FutureTask<>(myCallable);
        Thread thread = new Thread(futureTask);
        thread.start();

        try {
            Integer sum = futureTask.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}

```





## 4.5 三种实现方式优缺点

| 实现方式     | 优点                                                         | 缺点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 继承Thread   | 使用简单，可以直接使用Thread里面的方法                       | 可扩展性差，因为java是单继承，继承Thread之后就不能再继承其他类 |
| 实现Runnable | 扩展性强，JAVA是多实现，可以再去继承其他类                   | 编程稍微复杂，不能直接使用Thread里面的类                     |
| 实现Callable | 1）扩展性强，JAVA是多实现，可以再去继承其他类；2）具有返回值 | 编程稍微复杂，不能直接使用Thread里面的类                     |





# 5.Thread常见的成员方法

![image-20240507224024963](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240507224024963.png)

## 5.1 设置和获取线程的优先级

调度方式分为抢占式调度和非抢占式调度。

JAVA是抢占式调度，具有随机性，优先级越高，抢到CPU的概率越高（但是不是优先级越大，就一定先执行结束，只是概率高）。

默认的优先级是5

setPriority和getPriority



```java
public static void testExtendsThread() {
        System.out.println("------------------");
        System.out.println("创建MyThread线程，并调用start启动该线程");
        //主线程名字是：main	主线程的优先级是：5	主线程的ID是：1
        System.out.println("主线程名字是：" + Thread.currentThread().getName()
                + "\t主线程的优先级是：" + Thread.currentThread().getPriority()
                + "\t主线程的ID是：" + Thread.currentThread().getId());

        MyThread myThread1 = new MyThread();
        //实现构造函数，设置name
        MyThread myThread2 = new MyThread("线程2:");
        //通过setName方法设置线程名字
        myThread1.setName("线程1:");

        //线程1名字是：线程1:	线程1的优先级是：5	线程1的ID是：16
        System.out.println("线程1名字是：" + myThread1.getName()
                + "\t线程1的优先级是：" + myThread1.getPriority()
                + "\t线程1的ID是：" + myThread1.getId());
        //线程2名字是：线程2:	线程2的优先级是：5	线程2的ID是：17
        System.out.println("线程2名字是：" + myThread2.getName()
                + "\t线程2的优先级是：" + myThread2.getPriority()
                + "\t线程2的ID是：" + myThread2.getId());

        //设置线程等级：优先级从1-10，数值越大，优先级越高
        myThread1.setPriority(2);
        myThread2.setPriority(8);

        myThread1.start();
        myThread2.start();

    }
```

## 5.2 join插入线程

```
package ThreadDemo;

public class Thread2Test {
    public static void main(String[] args) {
        MyThread thread = new MyThread("子线程");
        thread.start();

        try {
            //join线程是插入线程，插入到当前线程的前面。
            //这里就是插入到主线程的前面
            thread.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        
        //结果输出
        //先执行结束子线程：子线程执行继承Thread的run方法
        //最后执行主线程：执行主线程main
        
        for (int i = 0; i < 20; i++) {
            System.out.println("执行主线程" + Thread.currentThread().getName());
        }
    }
}

```

# 6.线程的生命周期 几种状态

新建态：新创建一个线程

就绪态：执行start之后的状态，这个时候有执行资格，但是因为没有获取到CPU，所以没有执行权

运行态：在就绪态获取到CPU，开始执行

阻塞态：sleep或者其他阻塞方法，导致没有执行权和没有执行资格

死亡态：

![image-20240509223552557](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240509223552557.png)

注意：sleep方法会让线程进入睡眠状态，睡眠时间到了之后，不会立即执行后续的代码。

因为sleep之后就变成了就绪态，抢到CPU才能继续执行



# 7.多线程的安全问题

7.1 



## 7.2 同步代码块 synchronized 

 synchronized (MyThread2.class)

```
package ThreadDemo2;

public class MyThread2 extends Thread{

    static int ticket = 0;

    //注意：锁对象必须是唯一的，
    // 通常用字节码文件对象例如MyThread2.class，字节码文件对象是唯一的，同一个文件夹里面只有一个MyThread2.class
    // 或者使用静态对象，这里的静态对象就是类所持有的
    static Object obj = new Object();
    public MyThread2(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            //错误：表示没有锁，因为每次来的都是一个不同的锁来锁定，线程执行完再打开，相当于没有锁
//            synchronized (this) {
            //正确：字节码文件对象
//            synchronized (MyThread2.class) {
            synchronized (obj) {
                if (ticket < 20) {
                    System.out.println( getName() + "正在卖第" + (++ticket) + "张票");
                } else {
                    System.out.println("票已经卖完了");
                    break;
                }
            }
        }
    }
}

```


# P100 未知分类

# 1.键盘输入

存在两套体系，两套体系不能共用。

## 1.1第一套体系

遇到空格、制表符、回车就停止接收，这些数字后面的字符就不会接收了

```java
package Test;

import java.util.Scanner;

public class arrayClass {

    public static void main(String[] args) {
        //第一套体系：遇到空格、制表符、回车就停止接收，这些数字后面的字符就不会接收了
        //sc.nextInt()      接收整数
        //sc.nextDouble()   接受小数
        //sc.next()         接收字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个整数：");
        int a = sc.nextInt();
        System.out.println(a);
        System.out.println("请输入一个浮点数：");
        double d = sc.nextDouble();
        System.out.println(d);
        System.out.println("请输入一个字符串类型：");
        String s = sc.next();
        System.out.println(s);
    }

}

输出结果：
请输入一个整数：
12 34 56 78 99
12
请输入一个浮点数：
34.0
请输入一个字符串类型：
56

Process finished with exit code 0

分析：
我们输入的是12空格34空格56空格78空格99回车
这里的12后输入了一个空格这个时候停止接受，12就被传入到第一个sc.nextInt()
后面的34被下一个键盘输入nextDouble()接收
后面的56被下一个键盘输入 sc.next()接收，因为后面没有键盘接受，因此就停止接收

```



## 第二套体系

只有nextLine一套方法，用于接收字符串，可以接收空格和制表符，遇到回车才结束。

```
package Test;

import java.util.Scanner;

public class arrayClass {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
//        System.out.println("请输入一个整数：");
//        int a = sc.nextInt();
//        System.out.println(a);

        System.out.println("请输入一个字符串类型：");
        String s = sc.nextLine();
        System.out.println(s);

        System.out.println("请再次输入一个字符串类型：");
        String s2 = sc.nextLine();
        System.out.println(s2);
    }

}
package Test;

import java.util.Scanner;

public class arrayClass {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
//        System.out.println("请输入一个整数：");
//        int a = sc.nextInt();
//        System.out.println(a);

        System.out.println("请输入一个字符串类型：");
        String s = sc.nextLine();
        System.out.println(s);

        System.out.println("请再次输入一个字符串类型：");
        String s2 = sc.nextLine();
        System.out.println(s2);
    }

}

输出：
请输入一个字符串类型：
1235 45 66
1235 45 66
请再次输入一个字符串类型：
5656 4545 454 5666 66 
5656 4545 454 5666 66 

Process finished with exit code 0

分析：
这里遇到回车才结束，因此需要输出两次
```



## 1.3 混用

```java
package Test;

import java.util.Scanner;

public class arrayClass {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个整数：");
        int a = sc.nextInt();
        System.out.println(a);

        System.out.println("请输入一个字符串类型：");
        String s = sc.nextLine();
        System.out.println(s);

    }

}

输出1：
请输入一个整数：
12
12
请输入一个字符串类型：


Process finished with exit code 0

分析1：
这里输入12后回车，发现12输出后，第二个字符串没让输入直接输出了个回车就输出了。
这是因为后面的回车直接结束，因此没有输出。



输出2：
请输入一个整数：
123 456 789
123
请输入一个字符串类型：
 456 789

Process finished with exit code 0


分析2：
这里输入了123空格456空格789回车

空格以及后面的字符被当做一个字符串输出。
```



# 2.JavaBean类

JavaBean类就是不包含main方法的类。

标准的JavaBean类

1）类名药见名知意

2）成员变量要用private修饰

3）提供至少两个构造方法

- 无参构造方法
- 带全部参数的构造方法

4）成员方法

- 提供每一个成员变量对应的set和get方法
- 如果有其他行为也要写上



# 3.==到底比较的是什么

## 3.1 基本数据类型

比较的是数值，因为变量中存储的就是数值。



## 3.2 引用数据类型

比较的是地址，因为定义的变量中存储的是地址。



![image-20240331101414130](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240331101414130.png)





# 4.打印地址值

```
//打印出16进制的地址值，System.identityHashCode获取对象的哈希码，Integer.toHexString将哈希码转换成161进制字符串System.out.println(Integer.toHexString(System.identityHashCode(s1)));
```



# 5.int转char类型

```
int num = 66;
char ch = (char) (num + ’0‘);
System.out.println(ch); 


int num = 65;
char ch = Character.forDigit(num, 10);
System.out.println(ch); // 输出结果为 'A'


```



# 6.可变参数

JDK5之后出现可变参数

方法的形参个数是可以变化的，0,1,2,3,4,5

格式：数据类型...名称

例如：int...nums

可变参数底层实现就是一个数据，Java底层会帮我们实现

![image-20240427213957747](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240427213957747.png)

```JAVA
package Generics;

public class DynamicPara {
    public static void main(String[] args) {
        int[] nums = {1,2,3,4,5,6};
        System.out.println(sum(nums));
    }
    
    public static int sum(int ...args) {
        int sum = 0;
        for(int a : args) {
            sum += a;
        }
        return sum;
    }

    public static int sum2(int[] args) {
        int sum = 0;
        for(int a : args) {
            sum += a;
        }
        return sum;
    }
    
    /*
    // 错误1：只能写一个可变参数
    public static int sum3(int ...args,int ...ars) {
        int sum = 0;
        for(int a : args) {
            sum += a;
        }
        return sum;
    }
    
    //错误2：在方法形参中，如果有其他的参数，只能写在最后，因为写在前面会把后面的给接受
    public static int sum(int ...args,int l) {
        int sum = 0;
        for(int a : args) {
            sum += a;
        }
        return sum;
    }
    */
}

```



7.Collections  集合工具类

可以对集合进行批量添加，打乱顺序等等



```
package Generics;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Random;

public class CollectionsTest {
    public static void main(String[] args) {
        ArrayList<Integer> lists = new ArrayList<>();

        //批量添加元素
        Collections.addAll(lists,1,2,3,6,5,4,7,8,9);
        //打印 [1, 2, 3, 6, 5, 4, 7, 8, 9]
        System.out.println(lists);

        //打乱集合中元素顺序
        Collections.shuffle(lists);
        //打印 [1, 7, 9, 4, 3, 2, 5, 8, 6]
        System.out.println(lists);

        //对集合中的数据进行排序
        Collections.sort(lists);
        //[1, 2, 3, 4, 5, 6, 7, 8, 9]
        System.out.println(lists);

        //对集合中的数据进行倒序
        Collections.reverse(lists);
        // [9, 8, 7, 6, 5, 4, 3, 2, 1]
        System.out.println(lists);

        //获取集合中的最大值和最小值
        System.out.println(Collections.max(lists));
        System.out.println(Collections.min(lists));
        
        ArrayList<Integer> list2 = new ArrayList<>();
        Collections.addAll(list2,0,0,0,0,0,0,0,0,0,0,0);
        //将lists的值复制到list2中，list2的长度必须大于lists的长度
        Collections.copy(list2,lists);
        //打印[9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0]
        System.out.println(list2);


    }
}
```







Collections.java

```
private static Random r;

public static <T> boolean addAll(Collection<? super T> c, T... elements) {
    boolean result = false;
    Object[] var3 = elements;
    int var4 = elements.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        T element = var3[var5];
        result |= c.add(element);
    }

    return result;
}

public static void shuffle(List<?> list) {
    Random rnd = r;
    if (rnd == null) {
    	r = rnd = new Random();
    }

    shuffle(list, rnd);
}
```



# 7.静态代码块

特点：随着类的加载而加载，而且只执行一次。属于类而不是属于某一个实例化对象。

Main.java

```
import StaticTest.Game;

public class Main {
    public static void main(String[] args) {
        new Game();
        new Game();
        new Game();
    }
}

/*虽然创建了三个对象，但是静态代码块内容只打印了一次
打印静态代码块内容
[9, 6, 2, 1, 0]
[9, 6, 2, 1, 0]
[9, 6, 2, 1, 0]
*/
```



Game.java

```
package StaticTest;

import java.util.ArrayList;
import java.util.Collections;

public class Game {

    private int role;
    static ArrayList<Integer> list = new ArrayList<>();

    static {
        //role = 10;  //错误，错误，错误！静态代码块或者静态方法，只能调用静态变量或者静态方法。
        Collections.addAll(list,9,6,2,1,0);
        System.out.println("打印静态代码块内容");
    }

    public Game() {
        System.out.println(list);
    }
}

```



# 8.不可变集合

特点：集合创建之后，只能进行查询操作，无法进行增删改的操作。

使用场景：

![image-20240503172313727](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240503172313727.png)





![image-20240503172244034](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240503172244034.png)



测试：

```
package ImmuableCollection;

import java.util.List;
import java.util.Map;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        List<String> list = List.of("xiaozhou","xiaoyang","xiaoliu");
        Map<String,Integer> map = Map.of("xiaozhou",13,"xiaoyang",13,"xiaoyu",15);
        Set<String> set = Set.of("xiaozhou","xiaoyang","xiaoliu");
        System.out.println(list);
        System.out.println(map);
        System.out.println(set);
        list.add("cao");
        System.out.println(list);
    }
}



输出：
[xiaozhou, xiaoyang, xiaoliu]
{xiaoyang=13, xiaoyu=15, xiaozhou=13}
[xiaoyang, xiaoliu, xiaozhou]
Exception in thread "main" java.lang.UnsupportedOperationException
	at java.base/java.util.ImmutableCollections.uoe(ImmutableCollections.java:142)
	at java.base/java.util.ImmutableCollections$AbstractImmutableCollection.add(ImmutableCollections.java:147)
	at ImmuableCollection.Test.main(Test.java:15)

```

![image-20240503172358663](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240503172358663.png)



直接copy成不可变集合

```
package ImmuableCollection;

import java.util.List;
import java.util.Map;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        List<String> list = List.of("xiaozhou","xiaoyang","xiaoliu");
        Set<String> set = Set.of("xiaozhou","xiaoyang","xiaoliu");
        Map<String,Integer> map = Map.of("xiaozhou",13,"xiaoyang",13,"xiaoyu",15);
        System.out.println(list);
        System.out.println(set);
        System.out.println(map);

        Map<String, Integer> stringIntegerMap = Map.copyOf(map);
        Set<String> strings = Set.copyOf(set);
        List<String> list1 = List.copyOf(list);

        System.out.println(list1);
        System.out.println(strings);
        System.out.println(stringIntegerMap);
    }
}

```



例如：List、Set和Map的of方法

```
@SafeVarargs
static <E> List<E> of(E... elements) {
        switch (elements.length) {
            case 0:
                List<E> list = ImmutableCollections.EMPTY_LIST;
                return list;
            case 1:
                return new ImmutableCollections.List12(elements[0]);
            case 2:
                return new ImmutableCollections.List12(elements[0], elements[1]);
            default:
                return ImmutableCollections.listFromArray(elements);
        }
}

static <E> List<E> copyOf(Collection<? extends E> coll) {
        return ImmutableCollections.listCopy(coll);
}
    
    
@SafeVarargs
static <E> Set<E> of(E... elements) {
        switch (elements.length) {
            case 0:
                Set<E> set = ImmutableCollections.EMPTY_SET;
                return set;
            case 1:
                return new ImmutableCollections.Set12(elements[0]);
            case 2:
                return new ImmutableCollections.Set12(elements[0], elements[1]);
            default:
                return new ImmutableCollections.SetN(elements);
        }
}
    
static <E> Set<E> copyOf(Collection<? extends E> coll) {
        return coll instanceof ImmutableCollections.AbstractImmutableSet ? (Set)coll : of((new HashSet(coll)).toArray());
}
    
    
static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2) {
        return new ImmutableCollections.MapN(new Object[]{k1, v1, k2, v2});
}

static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
        return map instanceof ImmutableCollections.AbstractImmutableMap ? map : ofEntries((Entry[])map.entrySet().toArray(new Entry[0]));
}
    
    
```



# 9.Stream数据流



# 10.强引用、软引用、弱引用和虚引用

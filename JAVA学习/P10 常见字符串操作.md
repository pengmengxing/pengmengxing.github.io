# P10 常见字符串操作

# 1.String

## 1.1 String特点

- String是java定义好的一个类，在java.lang包中，所以在使用时不需要使用import导入包
- Java程序中的所有字符串文字（例如“abc"）都被认为是此类的对象
- 字符串不可变，它们的值在创建后不能更改

## 1.2 构造字符串

有多种构造方式，常用的有三种

1）直接赋值

2）传入字符数组char[]

3）传入字节数组byte[]

```
package Str;

public class StringTest {
    public static void main(String[] args) {
        //1.直接赋值
        String s1 = "abc";
        System.out.println(s1);
        //2.空参构造，获得一个空白的字符串对象，len是0
        String s2 = new String();
        System.out.println(" s2 = " + s2 + " s2.length = " + s2.length());

        //3.传入一个字符串，但是一般不这样用，比较常用直接赋值的方法
        //这里的new String("abc");是没有灰色的状态
        String s3 = new String("abc");
        System.out.println(s3);

        //4.传递一个字符数组，根据字符数组的内容创建一个新的字符串对象
        char[] chars = {'a','b','c'};
        String s4 = new String(chars);
        System.out.println(s4);

        //5.创建一个字节数组，根据字节数组的内容创建一个字符串对象
        //注意：这里是byte基本类型，而不是Byte引用数据类型
        //应用场景：在网络中传入的数据起始都死字节数据，（还有IO流）
        //我们要对字节信息进行转换，转成字符串，这个时候就用到这个构造了
        byte[] bytes = {97,98,99};
        String s5 = new String(bytes);
        System.out.println(s5);
    }
}


输出：
abc
 s2 =  s2.length = 0
abc
abc
abc

Process finished with exit code 0

```

## 1.3 String的内存模型

需要用到的内存空间

栈内存：方法运行时进栈，方法执行完毕出栈

堆内存：new出来的对象都在这里。字符串常量池也在这个空间



### 1.3.1 直接赋值

如果字符串在堆内存的字符串常量池中不存在，就先创建一个。已经存在，直接复用，直接将地址赋值过去。

如下所示，就是一个地址赋值给s2，这样的优点是节约内存。

![image-20240331095936913](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240331095936913.png)



### 1.3.2 通过new的方式创建

会在堆内存开辟新的内存空间，因此是不一样的。对于一个相同的字符串，可能会开辟多个内存，浪费空间。

![image-20240331100804856](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240331100804856.png)



## 1.4 常见方法

### 1.4.1 比较

比较的是具体的字符串值，而不是地址

equals						//必须完全一样

eaualsIgnoreCase	//忽略大小写，例如可以比较验证码



```java
package Str;

public class StringTest2 {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        String s3 = new String("abc");

        //打印出16进制的地址值，System.identityHashCode获取对象的哈希码，Integer.toHexString将哈希码转换成161进制字符串
        System.out.println(Integer.toHexString(System.identityHashCode(s1)));
        System.out.println(Integer.toHexString(System.identityHashCode(s2)));
        System.out.println(Integer.toHexString(System.identityHashCode(s3)));

        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);

        //s1是在字符串常量池开辟的内存空间，s2指向s1
        System.out.println(s1 == s2);
        //s2是在字符串常量池开辟的内存空间，s3是在堆内存开辟的空间
        System.out.println(s2 == s3);
        //比较字符串的内容
        System.out.println(s2.equals(s3));
    }
}


输出：
//s1和s2地址相同，s2和s3地址不同
16b98e56
16b98e56
7ef20235
//下面打印出来的不是地址是因为重写了toString方法，可以打印值
abc
abc
abc
true
false
true

Process finished with exit code 0

```

注意：键盘输入字符串时new的一个String，开辟的空间是在堆内存

```
package Str;

import java.util.Scanner;

public class StringTest2 {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        String s3 = new String("abc");

        Scanner sc = new Scanner(System.in);
        //注意这里的键盘输入的字符串，到底层本质上是new出来的String
        //因此s1是在字符串常量区，s4是在堆内存
        String s4 = sc.next();
        System.out.println(s1 == s4);
    }
}
输出：
abc
false
```



### 1.4.2 截取字符串

substring(start,end)前闭后开

substring(start)表示start到字符串的最后元素

其内部实现是new了一个String，因此需要有接收的String对象

```
    public static void main(String[] args) {
        String s = "123456789012";
        s.substring(0,5);
        //输出完整字符串，注意必须有接受的String
        System.out.println(s);
        
        String sub = s.substring(0,5);
        //输出前五个字符
        System.out.println(sub);
    }
    
输出：
123456789012
12345

Process finished with exit code 0
```



### 1.4.3 字符串替换

replaceFirst(String regex, String replacement)		//替换遇到的第一个regex

replace(CharSequence target, CharSequence replacement)	//替换所有的target

```
    public static void main(String[] args) {
        String s = "TTTMDTMD";
        //字符串替换也必须有返回值
        s.replace("TMD","***");
        System.out.println(s);

        String ss =  s.replace("TMD","***");
        System.out.println(ss);

        String ss2 =  s.replaceFirst("TMD","***");
        System.out.println(ss2);

        String ss3 =  s.replaceAll("TMD","***");
        System.out.println(ss3);

    }

    
输出：
TTTMDTMD
//替换所有的
TT******
//只替第一个
TT***TMD
//替换所有的
TT******

Process finished with exit code 0
```

### 1.4.4 字符串分割

split(String regex) 			//传入的是一个String字符串（是空格的话可以去除前后的空格，中间以空格作为区分，注意多个空格的情况），分割完之后的是一个String[]数组

```
public String[] split(String regex) {
	return this.split(regex, 0);
}
```

例子：

```
public static void main(String[] args) {
    String s = "AA BBB    VCVV   ";
    //字符串替换也必须有返回值，以空格作为分割
    String[] strs= s.split(" ");
    System.out.println(strs.length);
    printInfo(strs);

}

private static<E> void printInfo(E[] arr) {
    for (int i = 0; i < arr.length; i++) {
    	System.out.println(arr[i]);
    }
}

输出：
6
AA
BBB



VCVV

Process finished with exit code 0

分析：
这里的s字符串是有AA空格BBB空格空格空格空格VCVC组成
因此分割完之后就是 "AA","BB"," "," "," ","VCVC"
```



# 2.StringBuilder

String与StringBuilder区别：

1）String定义的字符串时不可更改的，扩充的+号实际上是new了一个新的String赋值给原来的，地址已经发生了变化。因此"+"每次都会在堆内存开辟一个空间。StringBuilder是可以动态变化的，是在原来的基础上进行增删改查。

```
package Str;

public class StringBuilderTest {
    public static void main(String[] args) {
        String str = "";
        long strStartTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            str += "A";
        }
        long strEndTime = System.currentTimeMillis();
//        System.out.println("str = " + str);
        System.out.println("String字符串扩充耗时 = " + (strEndTime - strStartTime) + "ms");
        System.out.println();

        StringBuilder strBulider = new StringBuilder();
        long strBuliderStartTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            strBulider.append("A");
        }
        long strBuliderEndTime = System.currentTimeMillis();
//        System.out.println("strBulider = " + strBulider.toString());
        System.out.println("StringBuilder字符串扩充耗时 = " + (strBuliderEndTime - strBuliderStartTime) + "ms");

    }
}


输出：
String字符串扩充耗时 = 2ms

StringBuilder字符串扩充耗时 = 0ms

Process finished with exit code 0


分析：
String字符串扩充因为每次都要在堆内存新开辟一个内存空间，频繁操作会比较耗时。
StringBuilder字符串是在原来的数组上进行操作，一直是在一个内存空间，容量动态扩充（最开始是8）

```



# 3.字符串拼接底层原理



```java
package Str;

public class StringPrinciple {
    public static void main(String[] args) {

        String s1 = "a";
        String s2 = s1 + "b";
        String s3 = s2 + "c";

        String s4 = "abc";
        String s5 = "a" + "b" + "c";

        //这里s4是在字符串常量池开辟的空间，记录的是串池中的地址值，s2和s3都是在堆内存中开辟的空间
        System.out.println(s3 == s4);   //false
        //这里会触发字符串优化机制，s5在编译时候直接将"abc"拼接，这样就是复用的字符创常量池中的值
        System.out.println(s4 == s5);   //true

        //capacity表示StringBuilder的容量，默认是16，是容纳的最大字符数量；
        //length表示长度，表示的是实际的存储长度
        StringBuilder stringBuilder = new StringBuilder();
        System.out.println(stringBuilder.capacity());       //16    默认容量16
        System.out.println(stringBuilder.length());         //0     没有元素，因此长度是0

        stringBuilder.append("abcdef");
        System.out.println(stringBuilder.capacity());       //16    默认容量16
        System.out.println(stringBuilder.length());         //6     6个元素，因此长度是6

        stringBuilder.append("abcdef");
        stringBuilder.append("abcdef");
        System.out.println(stringBuilder.capacity());       //34      超出默认尺寸，因此需要扩容，16*2+2=34
        System.out.println(stringBuilder.length());         //18      18个元素，因此长度是18

        stringBuilder.append("abcdef");
        stringBuilder.append("abcdef");
        stringBuilder.append("abcdef");
        stringBuilder.append("abcdef");
        System.out.println(stringBuilder.capacity());       //70      超出扩容尺寸，因此需要扩容，34*2+2=70
        System.out.println(stringBuilder.length());         //42      18个元素，因此长度是18
        //这里的toString是灰色的，表示没有使用，原因是println实现了toString方法，就会直接调用stringBuilder的toString，不用我们额外去调用
       	//System.out.println(stringBuilder.toString());    
        System.out.println(stringBuilder);   
        
        String ss1 = new String("abccc");
        String ss2 = new String("abccc");

        System.out.println(ss1.equals(ss2));                //true      因为String重写了Object的equals方法，里面比较的是字符串的值而不是地址
        System.out.println(ss1 == ss2);                     //false     ss1和ss2都是在堆内存开辟的空间，因此地址值是不同的

    }
}

//println底层实现
public void println(String x) {
    if (this.getClass() == PrintStream.class) {
        this.writeln(String.valueOf(x));
    } else {
        synchronized(this) {
            this.print(x);
            this.newLine();
        }
    }

}

public void print(String s) {
    this.write(String.valueOf(s));
}
//这里的Object是StringBuilder或者是String就去调用重写的toString方法，如果没有重写toString方法，就会调用Object的toString，会打印地址值
public static String valueOf(Object obj) {
    return obj == null ? "null" : obj.toString();
}

//String.java
public String toString() {
    return this;
}

public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    } else {
        boolean var10000;
        if (anObject instanceof String) {
            String aString = (String)anObject;
            if ((!COMPACT_STRINGS || this.coder == aString.coder) && StringLatin1.equals(this.value, aString.value)) {
                var10000 = true;
                return var10000;
            }
        }

        var10000 = false;
        return var10000;
    }
}



//StringBuilder.java
public String toString() {
    return this.isLatin1() ? StringLatin1.newString(this.value, 0, this.count) : StringUTF16.newString(this.value, 0, this.count);
}

//Object.java
public String toString() {
    return this.getClass().getName() + "@" + Integer.toHexString(this.hashCode());
}
//默认是直接比较
public boolean equals(Object obj) {
    return this == obj;
}


```

## 3.1 有变量参与的字符串拼接



![image-20240408225844673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240408225844673.png)



## 3.2 无变量参与的字符串拼接

![image-20240408230018677](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240408230018677.png)



## 3.3 StringBuilder进行字符串拼接

![image-20240408230124587](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240408230124587.png)

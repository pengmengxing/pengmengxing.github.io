# P20 集合

# 1.体系结构

## 1.1 单列集合

**Collection**

![image-20240409224418540](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240409224418540.png)

Collection是一个接口，不能直接创建它的对象，只能创建它的实现类的对象。可以使用多态的方式实现，父类指向子类对象，

例如：

```java
//前两种是多态的方式实现，
Collection<String> arraylist = new ArrayList<>();
List<String> arrayList2 = new ArrayList<>();
//直接使用具体的类创建一个对象
ArrayList<String> arrayList3 = new ArrayList<>();
```

## 问题：为什么要使用多态呢？



![image-20240409224714687](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240409224714687.png)

```
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class ListTest {
    public static void main(String[] args) {
        List<String> arraylist = new ArrayList<>();

        System.out.println(arraylist.isEmpty());    //true

        arraylist.add("aaa");
        arraylist.add("bbb");
        arraylist.add("ccc");
        arraylist.add("aaa");

        System.out.println(arraylist.isEmpty());    //false
        System.out.println(arraylist.size());       //4
        System.out.println(arraylist);              //[aaa, bbb, ccc, aaa]，这里可以添加重复的元素

        arraylist.remove("aaa");
        System.out.println(arraylist.size());       //3
        System.out.println(arraylist);              //[bbb, ccc, aaa]，这里只是移除了第一个匹配到的object

        arraylist.remove("bbb");
        System.out.println(arraylist.size());       //2
        System.out.println(arraylist);              //[ccc, aaa]，这里只是移除了第一个匹配到的object

        System.out.println(arraylist.contains("bbb"));       //false,上面已经删除
        arraylist.clear();
        System.out.println(arraylist.size());                //0，上面clear清除
    }
}

```



## 1.2 双列集合

**Map**



## 1.3 遍历方式

### 1.3.1 迭代器遍历

#### 1.3.1.1 关键函数

iterator()：获取迭代器对象，默认指向迭代器的第一个位置

hasNext()：判断当前位置是否有元素

next()：获取当前位置的值，并且移动到下一个位置

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListTest {
    public static void main(String[] args) {
        List<String> arraylist = new ArrayList<>();

        arraylist.add("aaa");
        arraylist.add("bbb");
        arraylist.add("ccc");
        arraylist.add("aaa");

        //打印结果  aaa bbb ccc aaa 
        printList(arraylist);

    }

    //迭代器
    static<E> void printList(List<E> list) {
        //获取迭代器对象，默认指向迭代器的第一个位置
        Iterator<E> iterator = list.iterator();
        //iterator.hasNext判断当前位置是否有元素
        while (iterator.hasNext()) {
            //iterator.next()获取当前位置的值，并且移动到下一个位置
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
}

```

#### 1.3.1.2 细节注意点

1）循环结束后，迭代器的指针指向最后没有元素的位置，这时候再访问next时候会报java.util.NoSuchElementException

2）迭代器结束后不会复位，即一直指向最后的位置，如果想再次使用需要重新创建一个迭代器

3）迭代器遍历时候，不能使用集合的方式进行增加或者删除。如果要删除，可以使用迭代器的remove()方法。



### 1.3.2 增强for遍历

增强for遍历适用于单列集合和数组。

```java
static<E> void printList2(List<E> list) {
    for (E l : list) {
        System.out.print(l + " ");
    }
    System.out.println();
}
```



### 1.3.3 匿名函数

```
    static<E> void printLambda(List<E> list) {
        //匿名内部类
        //底层原理是forEach的底层就是自己遍历集合，依次得到每一个元素，把得到的每一个元素传递给accept方法，这里的s就是集合中的每一个数据
        //1.原始表达方式
        list.forEach(new Consumer<E>() {
            @Override
            public void accept(E e) {
                System.out.print(e + " ");
            }
        });
        System.out.println();
        //2.改写1 删除new到accept的部分，并删除多余的}
        list.forEach((E e) -> {System.out.print(e + " ");});
        System.out.println();
        //3.进一步精简,变量类型可以省略，直接在list可以获取到具体的类型，因为只有一行，可以删除大括号
        list.forEach(e ->System.out.print(e + " "));
        System.out.println();

    }
```





# 2.单列集合

分为两大类：List和Set。

List集合特点：添加的元素有序、可重复、有索引。这里的有序是按照添加的顺序，不是排序。

Set集合特点：添加的元素是无序、不重复、无索引

## 2.1 List集合

### 2.1.1 特有函数

    /*
    * boolean add(E var1);
    * void add(int var1, E var2);   //list独有，指定索引处插入指定元素
    * E remove(int var1);           //list独有 ,删除指定位置雅元素，并返回删除的值
    * boolean remove(Object var1);
    * E set(int var1, E var2);      //list独有，修改索引处的值，返回被修改的元素
    * E get(int var1);              //list独有，获取索引处的值
    * */

```
    public static void main(String[] args) {


        List<String> arraylist = new ArrayList<>();
        List<Integer> arraylist2 = new ArrayList<>();

        arraylist.add("aaa");
        arraylist.add("bbb");
        arraylist.add("ccc");
        arraylist.add("aaa");

        arraylist2.add(1);
        arraylist2.add(2);
        arraylist2.add(3);


        printList1(arraylist);      //aaa bbb ccc aaa
        arraylist.add(1,"sss");//在索引为1的位置添加字符串"sss"，后面的索引后移
        printList2(arraylist);      //aaa sss bbb ccc aaa
        arraylist.set(1,"nnn");
        printList2(arraylist);      //aaa nnn bbb ccc aaa
        System.out.println(arraylist.get(0));   //aaa，获得0索引的值

        arraylist2.remove(1);       //打印1 3，删除的是2，注意这里删除的是索引为1的元素，因为remove重载了，优先调用实参和形参类型一样的，所以优先匹配的是int类型的
        printLambda(arraylist2);

        Integer i = Integer.valueOf(1); //手动装箱，手动吧基本数据类型1变成Integer类型
        arraylist2.remove(i);           //这里移除的是1，调用的是Object类型的
        printLambda(arraylist2);


        //打印结果  aaa bbb ccc aaa
//        printList1(arraylist);
//        printList2(arraylist);
//        printLambda(arraylist);

    }
```



### 2.1.2 特有遍历方式

除了上面说的三种迭代器遍历、增强for遍历和匿名函数foreach遍历，还有两种列表迭代器和普通for循环。

#### 2.1.2.1 列表迭代器

listIterator是list特有的一个遍历方式，特点是可以在遍历时候进行remove操作。

```
 static<E> void printList5(List<E> list) {
    Iterator<E> iterator = list.listIterator();
    while (iterator.hasNext()){
        System.out.print(iterator.next() + " ");
    }
    System.out.println();
}
```

#### 2.1.2.2 普通for循环

```
static<E> void printList3(List<E> list) {
    for (int i = 0;i < list.size();i++) {
        System.out.print(list.get(i) + " ");
    }
    System.out.println();
}
```

### 2.1.3 ArrayList集合底层

从ArrayList的名字可以看出来是数组形式的list，底层就是数组。

![image-20240413165752762](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240413165752762.png)



### 2.1.4 LinkedList集合底层

从LinkedList名字可以看出来是链表形式的list，底层是双链表。

![image-20240413170224135](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240413170224135.png)

```java
package Test;

import java.util.LinkedList;

public class LinkedListTest {
    public static void main(String[] args) {
        LinkedList<String> lists = new LinkedList<>();
        lists.add("aaa");
        lists.add("bbb");
        lists.add("ccc");
        lists.addFirst("xxx");//在list头部添加
        lists.addLast("yyy");//在list尾部添加
        System.out.println(lists);//[xxx, aaa, bbb, ccc, yyy]
        System.out.println(lists.getFirst());//xxx
        System.out.println(lists.getLast());//yyy
        lists.removeFirst();    //等同于remove，remove内部调用的removeFirst
        System.out.println(lists);//[aaa, bbb, ccc, yyy]
        lists.removeLast();
        System.out.println(lists);//[aaa, bbb, ccc]

    }
}

```

## 2.2 Set集合

特点：无序、不重复和无索引。

实现基本上与接口Collection的API一致。

无序：存取数组没有顺序。

不重复：不允许有重复数据，重复数据不会被添加进去。

无索引：不能使用普通for循环进行遍历。 

set集合的实现类分为三种：HashSet、LinkedHashSet和TreeSet

特点：

HashSet：无序，不重复，无索引

LinkedHashSet：有序（按照添加的顺序），不重复，无索引

TreeSet：可排序（对添加的数据进行排序），不重复，无索引





### 2.2.1 HashSet

#### 2.2.1.1 HashSet底层原理

JDK8以前：数组+链表

JDK8及之后：数组+链表+红黑树

![image-20240420174129215](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240420174129215.png)

注意：

JDK8之前之后的区别主要是5

0.75表示：如果存储的元素是16*0.75个的时候，会扩容到16乘以2

当链表长度超过8，而且数组长度大于等于64时候，自动转换为红黑树。

如果集合存储的自定义对象，必须重写hashCode和equals方法。



#### 2.2.1.2  HashSet的三个问题

##### 为什么HashSet存储和读取的顺序不一样？

存的的时候不一定是按照数组的顺序去存储的，而是通过元素的hashcode找到相应的地址去存储到数组。读取的时候是按照顺序的方式读取。



##### 为什么HashSet不重复？

通过hashCode方法来找到数组中的地址值，通过equals来比较属性值。基本类型不用重写hashCode和equals，对于自定义对象，必须重写hashCode和equals方法。



##### 为什么HashSet无索引？

数组的位置有可能挂载链表或者红黑树，无法确定索引。



测试

```java
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public class setTest {
    public static void main(String[] args){
        Student stu1 = new Student("xiaozhou",13);
        Student stu2 = new Student("xiaozhou",13);

        ////无重写equals和hashCode方法
        Set<Student> studentSet = new HashSet<>();
        studentSet.add(stu1);
        studentSet.add(stu2);
        //stu1哈希值 = 2129789493
        //stu2哈希值 = 668386784
        System.out.println(" stu1哈希值 = " + stu1.hashCode());
        System.out.println(" stu2哈希值 = " + stu2.hashCode());
        //[Student@27d6c5e0, Student@7ef20235]
        System.out.println(studentSet);

        //2.在Friend重写hashCode方法,属性值一样，hascode值一样
        Friend f1 = new Friend("mengyang",13);
        Friend f2 = new Friend("mengyang",13);

        //重写了equals和hashCode方法
        Set<Friend> friendSet = new HashSet<>();
        friendSet.add(f1);
        friendSet.add(f2);
        // f1哈希值 = -1904118148
        // f2哈希值 = -1904118148
        System.out.println(" f1哈希值 = " + f1.hashCode());
        System.out.println(" f2哈希值 = " + f2.hashCode());
        //[Friend@8e81767c]
        System.out.println(friendSet);
    }
}

class Student{
    private String name;
    private int age;

    Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Friend{
    private String name;
    private int age;

    Friend() {

    }

    public Friend(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Friend friend = (Friend) o;
        return age == friend.age && Objects.equals(name, friend.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

```





 #### 2.2.1.3 哈希值与对象的哈希值的特点



![image-20240420171813142](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240420171813142.png)

测试：

```java
import java.util.Objects;

public class setTest {
    public static void main(String[] args){
        Student stu1 = new Student("xiaozhou",13);
        Student stu2 = new Student("xiaozhou",13);

        //1.在Student中不重写hashCode方法，默认调用Object的hashCode,不一样
        System.out.println(stu1.hashCode());    //1313922862
        System.out.println(stu2.hashCode());    //495053715

        //2.在Friend重写hashCode方法,属性值一样，hascode值一样
        Friend f1 = new Friend("mengyang",13);
        Friend f2 = new Friend("mengyang",13);

        System.out.println(f1.hashCode());    //-1904118148
        System.out.println(f2.hashCode());    //-1904118148

        //3.String重写了hashCode方法，但是出现了哈希碰撞，导致一样，小概率递减
        System.out.println("abc".hashCode());   //96354
        System.out.println("acD".hashCode());   //96354
    }
}

class Student{
    private String name;
    private int age;

    Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Friend{
    private String name;
    private int age;

    Friend() {

    }

    public Friend(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Friend friend = (Friend) o;
        return age == friend.age && Objects.equals(name, friend.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```



### 2.2.2 LinkedHashSet

继承于HashSet，因此方法实现基本一样，但是在**有序**区别于HashSet。

**特点：**有序、不重复、无索引。

有序是指：存储和读取顺序一致。

**原理：**底层数据结构是哈希表，知识每个元素又额外多了一个双链表的机制存储记录的顺序。

![image-20240420180801757](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240420180801757.png)



### 2.2.3 TreeSet

特点：**有序**，无重复，无索引

底层是红黑树，实现排序。

默认的规则

1.对于数值类型：Integer、Double默认是按照从小到大的顺序进行排序

2.对于字符、字符串，按照字符在ASCII码表的数字升序进行排序

3.对于自定义对象，需要我们去定义或者自己书写比较规则。



![image-20240421105952744](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421105952744.png)



#### 2.2.3.1 TreeSet的两种比较方式

##### 默认排序/自然排序

**默认使用此种方式**

JavaBean类实现Comparable接口制定比较规则

需要实现Comparable接口的compareTo方法书写规则，如果不添加比较的规则会抛出异常。

```java
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;

public class setTest {
    public static void main(String[] args){
        Student stu1 = new Student("xiaozhou",13);
        Student stu2 = new Student("xiaopeng",14);
        Student stu3 = new Student("xiaoyu",15);
        Student stu4 = new Student("xiaozhou",13);
        Student stu5 = new Student("xiaosun",17);

        //[Student{name='xiaozhou', age=13}, Student{name='xiaopeng', age=14}, 
        //Student{name='xiaoyu', age=15}, Student{name='xiaosun', age=17}]
        TreeSet<Student> studentTreeSet = new TreeSet<>();
        studentTreeSet.add(stu3);
        studentTreeSet.add(stu4);
        studentTreeSet.add(stu5);
        studentTreeSet.add(stu1);
        studentTreeSet.add(stu2);

        System.out.println(studentTreeSet);
    }
}

class Student implements Comparable<Student>{
    private String name;
    private int age;

    Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student student) {
        return this.age - student.age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



##### 比较器排序

使用TreeSet的比较器构造方法

```
public TreeSet(Comparator<? super E> comparator) {
    this((NavigableMap)(new TreeMap(comparator)));
}
```

例子：

```
//使用自然规则，ASCII自然升序方式
TreeSet<String> treeSet1 = new TreeSet<>();
treeSet1.add("a");
treeSet1.add("ba");
treeSet1.add("acb");

//输出 [a, acb, ba]
System.out.println(treeSet1);


//使用我们自定义规则，先进行长度，再自然排序
TreeSet<String> treeSet2 = new TreeSet<>(new Comparator<String>() {
//注意比较器的传参：s表示当前添加的元素，t1表示已经存在红黑树的元素
//返回值规则：0表示添加的元素已经存在不添加，差值正数表示比已经存在的值大，存红黑树右边，差值负数表示比已经存在的值小，存红黑树左边
    @Override
    public int compare(String s, String t1) {
        int res = s.length() - t1.length();
        res = (res == 0 ? s.compareTo(t1) : res);
        return res;
		}
	});
//修改成匿名函数方式
//        TreeSet<String> treeSet2 = new TreeSet<>((s, t1) -> {
//                int res = s.length() - t1.length();
//                res = (s.length() - t1.length() == 0 ? s.compareTo(t1) : res);
//                return res;
//        });

treeSet2.add("a");
treeSet2.add("ba");
treeSet2.add("acb");
//输出：[a, ba, acb]
System.out.println(treeSet2);
```



比较器排序对于自定义对象排序

```java
import java.util.*;

public class setTest {
    public static void main(String[] args){
        Student stu1 = new Student("xiaozhou",13);
        Student stu2 = new Student("xiaopeng",14);
        Student stu3 = new Student("xiaoyu",15);
        Student stu4 = new Student("xiaozhou",13);
        Student stu5 = new Student("xiaosun",17);
        
        TreeSet<Student> studentTreeSet = new TreeSet<>();
        studentTreeSet.add(stu3);
        studentTreeSet.add(stu4);
        studentTreeSet.add(stu5);
        studentTreeSet.add(stu1);
        studentTreeSet.add(stu2);

        //[Student{name='xiaozhou', age=13}, Student{name='xiaopeng', age=14}, 
        // Student{name='xiaoyu', age=15}, Student{name='xiaosun', age=17}]
        System.out.println(studentTreeSet);

        Student2 stu6 = new Student2("xiaozhou",13);
        Student2 stu7 = new Student2("xiaopeng",14);
        Student2 stu8 = new Student2("xiaoyu",15);
        Student2 stu9 = new Student2("xiaozhou",13);
        Student2 stu10 = new Student2("xiaosun",17);

        TreeSet<Student2> studentTreeSet2 = new TreeSet<>(new Comparator<Student2>() {
            @Override
            public int compare(Student2 student2, Student2 t1) {
                return student2.getAge() - t1.getAge();
            }
        });
        studentTreeSet2.add(stu6);
        studentTreeSet2.add(stu7);
        studentTreeSet2.add(stu8);
        studentTreeSet2.add(stu9);
        studentTreeSet2.add(stu10);

        //[Student2{name='xiaozhou', age=13}, Student2{name='xiaopeng', age=14},
        // Student2{name='xiaoyu', age=15}, Student2{name='xiaosun', age=17}]
        System.out.println(studentTreeSet2);


    }
}

//实现Comparable接口
class Student implements Comparable<Student>{
    private String name;
    private int age;

    Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Student student) {
        return this.age - student.age;
    }
}


//没有实现Comparable接口，直接再TreeSet的构造方法中构造比较规则Comparator

class Student2{
    private String name;
    private int age;

    Student2() {

    }

    public Student2(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Student2{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```





## 2.3 集合使用场景以及优势劣势

集合元素可重复

使用ArrayList，基于数组。也是使用最多的

优点：基于数组，查询时间复杂度是O(1)，速度快

缺点：增删操作时间复杂度是O(n)，涉及的元素需要挪动位置



集合元素可重复，增删多于查询

使用LinkedList，基于链表。

优点：基于链表，每一个节点都是独立的，添加和删除的时间复杂度是O(1)，速度快。

缺点：查找的时间复杂度是O(n)，需要遍历整个链表



集合元素需要去重

使用HashSet，基于哈希表。也是使用最多的



集合元素需要去重，存取有序

使用LinkedHashSet集合

优点：基于哈希表和双链表，效率比HashSet低



集合元素需要去重，排序

使用TreeSet集合

优点：基于红黑树，效率高



# 3.双列集合

查看单列set集合的原码可以发现底层都是Map,例如

HashSet底层

```
public LinkedHashSet(int initialCapacity) {
    super(initialCapacity, 0.75F, true);
}
```



LinkedHashSet底层

```java
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    this.map = new LinkedHashMap(initialCapacity, loadFactor);
}
```



TreeSet底层

```
public TreeSet() {
    this((NavigableMap)(new TreeMap()));
}
```

## 3.1 Map的特点

![image-20240421114434154](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421114434154.png)





## 3.2 Map的常见API

![image-20240421114502443](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421114502443.png)



```
package Map;

import java.util.HashMap;
import java.util.Map;

public class MapBasic {
    public static void main(String[] args) {
        Map<String,Integer> m = new HashMap<>();
        //put添加元素，如果存在则使用新值覆盖
        m.put("xiaozhou",18);
        m.put("xiaoyang",14);
        m.put("xiaoyu",15);
        m.put("xiaopeng",16);
        m.put("xiaozhou",13);
        System.out.println(m);

        //移除某一个key的键值对
        m.remove("xiaoyu");
        System.out.println(m);

        //获取某个键的值
        int xiaozhouage = m.get("xiaozhou");
        System.out.println(xiaozhouage);

        //获取某个键的值，没有找到默认设置为某一个值
        int xiaowangage = m.getOrDefault("xiaowang",15);
        System.out.println(xiaowangage);

        //判断某个键是否存在
        boolean isExistXiaozhou = m.containsKey("xiaozhou");
        System.out.println(isExistXiaozhou);


        //判断是否存在某一个值
        boolean isExist25 = m.containsValue(25);
        System.out.println(isExist25);

        //是否为null
        boolean isEmpty = m.isEmpty();
        System.out.println(isEmpty);

        //map的size
        int size = m.size();
        System.out.println(size);

        //清空map
        m.clear();
        System.out.println(m);
    }
}

```

## 3.3 Map的遍历方式

测试

```java
public static void main(String[] args) {
    Map<String,Integer> map1 = new HashMap<>();
    map1.put("xiaozhou",15);
    map1.put("xiaomeng",13);
    map1.put("xiaoyang",16);
    map1.put("xiaoyu",13);
    map1.put("xiaosun",12);
    System.out.println(map1);
    keyFindValue(map1);
    keyValuePair(map1);
    mapLambda(map1);
}
```

### 3.3.1 键找值

```java
static void keyFindValue(Map<String,Integer> map) {
        Set<String> set1 = map.keySet();
        set1.forEach((str)->{
            System.out.print(str + "=" + map.get(str) + " ");
        });
        System.out.println();

        Iterator<String> iterator = set1.iterator();
        while (iterator.hasNext()) {
            System.out.print(map.get(iterator.next()) + " ");
        }
        System.out.println();
        for (String str :
                set1) {
            System.out.print(map.get(str) + " ");
        }
        System.out.println();
    }
```



### 3.3.2 键值对

```java
static void keyValuePair(Map<String,Integer> map) {
    Set<Map.Entry<String, Integer>> entries = map.entrySet();
    for (Map.Entry entry: entries) {
        System.out.print(entry.getKey() + "=" + entry.getValue() + " ");
    }
    System.out.println();

    Iterator<Map.Entry<String,Integer>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String,Integer> cur = iterator.next();
        System.out.print(cur.getKey() + "=" + cur.getValue() + " ");
    }
    System.out.println();

    map.entrySet().forEach((entry)->{
        System.out.print(entry.getKey() + "=" + entry.getValue() + " ");
    });
    System.out.println();
}
```

### 3.3.3 Lambda表达式

```java
//map的foreach底层就是使用键值对Entry实现的
static void mapLambda(Map<String,Integer> map) {
    map.forEach(new BiConsumer<String, Integer>() {
        @Override
        public void accept(String key, Integer value) {
            System.out.print(key + "=" + value + " ");
        }
    });
    System.out.println();

    map.forEach((key,value) ->
            System.out.print(key + "=" + value + " "););
    System.out.println();
}
```

## 3.4 三种Map

### 3.4.1 HashMap

#### 哈希表结构

JDK之前：数组+链表

JDK8以及之后：数组+链表+红黑树

![image-20240421185837230](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421185837230.png)

#### HashMap特点

只关注键是不是自定义对象，不需要关注值。底层是哈希表，哈希表例存储的Entry对象

![image-20240421190101420](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421190101420.png)

#### HashMap添加元素底层原理

注意：数组中存放的Node，可以是链表，可以是红黑树，要看具体情况

添加元素至少存在三种情况

1）数组位置为null

直接通过newNode创建一个Node存入计算出来的数组的索引处

2）数组位置不是null，键不重复

挂在计算的数组位置下面形成链表或者红黑树

3）数组位置不是null，键重复

覆盖之前的元素

```java
//默认容量是16，当第一个put进行添加有元素后，table的容量设置为16，初始是0
static final int DEFAULT_INITIAL_CAPACITY = 16;
//最大的容量是1<<30,也就是2的30次方
static final int MAXIMUM_CAPACITY = 1073741824;
//默认的加载因子（扩容因子）是0.75
static final float DEFAULT_LOAD_FACTOR = 0.75F;
//HashMap的底层是数组+链表，数组里面存的是Node节点（对应key和value）
transient Node<K, V>[] table;
transient Set<Map.Entry<K, V>> entrySet;
final float loadFactor;

//初始化空的HashMap时候设置的加载因子loadFactor是0.75
public HashMap() {
     this.loadFactor = 0.75F;
}

//put进行添加时候，会先判断该key的hash值是否存在
public V put(K key, V value) {
	return this.putVal(hash(key), key, value, false, true);
}

//如果table不等于空，就使用table的长度
final int capacity() {
    return this.table != null ? this.table.length : (this.threshold > 0 ? this.threshold : 16);
}


public V put(K key, V value) {
        return this.putVal(hash(key), key, value, false, true);
    }


final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
        Node[] tab;
    	//n表示当前数组的长度，没添加元素之前，长度是0
        int n;
   		//如果是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组
    	//长度被调整为16
    	//如果不是第一次添加数据，会在resize中判断数组中的元素是否达到的扩容的条件
    	//如果没有达到扩容的条件，底层不会做任何操作
    	//如果达到了扩容条件，底层会把数组扩容到原先的两倍，并把数据全部转移到新的哈希表
        if ((tab = this.table) == null || (n = tab.length) == 0) {
            n = (tab = this.resize()).length;
        }

    	//计算出的索引在数组中的值
        Object p;
        int i;
    	//hash是计算出的键的hash值，与数组的长度进行运算，计算出数组的索引i，再计算出当前的键值对对象，在数组中存入相应的位置
        if ((p = tab[i = n - 1 & hash]) == null) {
            //1）获取到数组中对应元素的数据，如果为null，底层通过newNode创建一个节点存入到数据对应的索引处
            tab[i] = this.newNode(hash, key, value, (Node)null);
        } else {
            Object e;
            Object k;
            if (((Node)p).hash == hash && ((k = ((Node)p).key) == key || key != null && key.equals(k))) {
                e = p;
            } else if (p instanceof TreeNode) {
                //判断数组中获取的键值对是不是红黑树的节点
                //如果是，调用方法putTreeVal，按照红黑树的规则添加当前节点到当前树中
                e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);
            } else {
                int binCount = 0;
				//如果从数组中获取的键值对p不是红黑树的节点
                //表示当前挂的是链表
                while(true) {
                    if ((e = ((Node)p).next) == null) {
                        //此时就会创建一个新的节点，挂在下面形成链表
                        ((Node)p).next = this.newNode(hash, key, value, (Node)null);
                        //如果当前的链表长度超过8，就会调用treeifyBin
                        //treeifyBin还会继续判断数组的长度是否超过64，
                        //同时满足这两个条件，就会把链表转化为红黑树
                        if (binCount >= 7) {
                            this.treeifyBin(tab, hash);
                        }
                        break;
                    }
                    
					//还是2）情况，一直判断链表节点的hash值是否与我们计算的hash值是否相同，相同的话判断键的值是否相同，相同则break
                    if (((Node)e).hash == hash && ((k = ((Node)e).key) == key || key != null && key.equals(k))) {
                        break;
                    }

                    p = e;
                    ++binCount;
                }
            }
			//如果e为null，表示不需要覆盖，直接返回null
            //3）如果e不是null，直接将val修改e的val，这里不是将整个键值对放到计算的索引处，而是保留旧的键值对，直接更改val值
            if (e != null) {
                V oldValue = ((Node)e).value;
                if (!onlyIfAbsent || oldValue == null) {
                    ((Node)e).value = value;
                }

                this.afterNodeAccess((Node)e);
                return oldValue;
            }
        }

        ++this.modCount;
        if (++this.size > this.threshold) {
            this.resize();
        }

        this.afterNodeInsertion(evict);
        return null;
}
```

![image-20240427212642567](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240427212642567.png)



#### 什么是哈希冲突，HashMap如何解决哈希冲突？





### 3.4.2 LinkedHashMap

继承于HashMap，区别于HashMap主要是存取有序。

![image-20240423231509198](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240423231509198.png)



### 3.4.3 TreeMap

如果两种排序都写了，以第二种方式为准。

优点：增删改查性能较好。因为底层是红黑树

![image-20240423232015809](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240423232015809.png)





### 3.4.4 HashTable



## 3.5 Capacity Map的扩容机制

### 3.5.1 默认容量、扩容因子

```

```